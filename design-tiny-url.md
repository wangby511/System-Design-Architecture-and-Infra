# Design Tiny URL Service System

## Functional requirements

1. URL shortening: given a long url, return a short url

2. URL redirecting: given a short url, redirect to the original long url

3. The user can pick up a special alias.

4. The user can define the specific expiry time for a short url. Or should we add expiry time for shortURL?

5. Can one longURL have multiple/several shortURLs? Will the system return two different short URLs when given the same long URL? Based on if we need user authentication. To be discussed. **Should we deduplicate?**

## Non-Functional requirements

High availability with fault tolerance, scalability in service.

Real-time with minimum latency in redirection.

Shortened URLs are not guessable or predictable.

## QPS & Estimations

DAU 1 million

### Create

Per day 1,000,000 *1% (function usage)* 10 (function frequency) = 100,000

Per second: 100,000 / 86,400 = 1.2

### Lookup

Per day : 1,000,000 *100% (function usage)* 3 (function frequency) = 3,000,000

Per second: 3,000,000 / 86400 = 35

### Estimations

Write Bandwidth : 100KB/s

Read Bandwidth : 10MB/s

Read/Write ratio 10:1 ~ 100:1. This is a read-heavy system.

## APIs

### 1. POST api/v1/data/shorten

```
Request parameters {

    string : longURL

　　 long : expiry time (optional)

　　 string : special alias (optional)
}

Response parameters {

    string: shortURL

}
```

201 Created

### 2. GET api/v1/getUrl {shortURL}  {Return longURL for HTTP redirection}

~~301(permanently and the browser caches the response)~~

302(temporarily redirecting and we are able to do analytics)

## Storage/DB

<shortURL(6 Bytes per shortURL), longURL, (expiry time)>

## Encoding actual longURL Algorithms

### Algorithm 1 - Use MD5/SHA1

E.g. MD5 128bit -> 22 64-Based encoding characters (since each base64 character encodes 6 bits of the hash value)

1) We can take the first 6 (or 7, 8) letters for the key. This could result in key duplication; to resolve that, we can choose some other characters out of the encoding string or swap some characters.

or SHA-1, SHA-2, SHA-256.

62^7 = 3.5 trillion

Pros: It does not need a unique ID generator. The collision is possible and needs to be resolved.

### Algorithm 2 - Generating shortURLs offline

### Algorithm 3 - Unique ID Generator & Base 62 conversion

1) UUID. 32 16-bit characters. 16 Bytes.

2) Multiple MySQL servers. Randomly pick a server.

3) Twitter / Snowflake ID - 64 bits. 1 + 41 timestamp + 10 machine numbers + 12 sequence. Then do the conversion based on 62 or 64. E.g. gk.link/a/3hcCxy

This needs a unique ID generator But collision is not possible.

## Flows (Steps)

### URL Shortening Steps

1 An user gives a long url input.

(1.5) The web server checks if the same long url is converted before and check if the malicious user.

2 A new unique ID is generated by the unique ID generator.

3 The server converts that ID to short url with base 62 or 64 conversion.

4 The server saves the record to the database and returns the result to the user.

### URL Redirecting Steps

1 An user clicks a short url.

2 The web server checks the validation, then checks the cache and returns the long url if it exists.

3 If not, check the bloom filter and fetch it from the database.

4 The long url is returned to the user and does the redirection operation.

## Data Partition

Purpose: Scale out DB

Split the DB based on hash function and consistency hashing mechanism.

Consistency Hash: Consistent Hashing stores the data managed by a distributed system in a ring. Each node in the ring is assigned with a range of data.

## Storage

LongUrl 100 bytes + shortUrl 6 bytes + STATE 4 bytes = 110 bytes

110 bytes * 3,000,000 = 330 MB / day

330 MB * 365 = 120 GB / year

## Cache

Cache Size : 20K requests/s *3600* 24 = 1.728 billion.

1.728 billion *0.5KB* 20% = 172.8 GB ~ 170 GB.

It can be a single machine based on calculation. LRU strategy.

## Rate Limiter

Ban the malicious user temporarily if it makes requests too many times in a short period of time.

## Expiry - Lazy Clean up

## ID Generator

Each region has a machine as the ID generator. A central data server maintains a table for the range of IDs in each regional machine. E.g.

Machine A (region A) can assign 0-999.

Machine B (region B) can assign 1000-1999.

Machine D (region D) can assign 2000-2999.

...

When a machine has used up its current range (1000 IDs), it is going to apply for a new range to the central data center server. The central server will fetch & return the next range of numbers to it. (It can keep an atomic number or build a DB for maintain the current range mapping).

## Infra Graph

![image](https://www.raychase.net/wp-content/uploads/2020/12/Short-URL.png)

(Source : <https://www.raychase.net/6460>)

## Reference

[1] <https://zybuluo.com/ysongzybl/note/95360>

[2] <https://www.educative.io/courses/grokking-the-system-design-interview/>

[3] [四火的唠叨]<https://www.raychase.net/6460>

[4] System Design Interview. Alex Xu. Chapter 8. Design a url shortener.

[5] <https://www.1point3acres.com/bbs/thread-829896-1-1.html>
