# System Design - Tiny URL Service

## Functional Requirements

1. URL shortening - Given a long URL, return a short URL.

2. URL redirecting - Given a short URL, redirect to the original long URL.

3. The user can pick up a special/custom alias for their short link URL.

4. The user can define the specific expiry time for a short URL. Or should we allow users to specify the expiration time for shortURL?

5. Can one longURL have multiple/several shortURLs? Will the system return two different short URLs when given the same long URL? Based on if we need user authentication. To be discussed. **Should we deduplicate?**

## Non-Functional Requirements

High availability with fault tolerance, scalability in service.

Real-time with minimum latency in redirection.

Shortened URLs are not guessable or predictable.

## QPS & Estimations

DAU 1 million

### Create

Per day 1,000,000 *1% (function usage)* 10 (function frequency) = 100,000

Per second: 100,000 / 86,400 = 1.2

### Lookup

Per day : 1,000,000 *100% (function usage)* 3 (function frequency) = 3,000,000

Per second: 3,000,000 / 86400 = 35

### Estimations

Write Bandwidth : 100KB/s

Read Bandwidth : 10MB/s

Read/Write ratio 10:1 ~ 100:1. This is a read-heavy system.

## APIs

### 1. POST api/v1/data/shorten

```
Request parameters {

    string : longURL

　　 long : expiry time (optional)

　　 string : special alias (optional)
}

Response parameters {

    string: shortURL

}
```

201 Created

### 2. GET api/v1/getUrl {shortURL}  {Return longURL for HTTP redirection}

~~301(permanently and the browser caches the response)~~

302(temporarily redirecting and we are able to do analytics)

## Storage/DB

<shortURL(X Bytes per shortURL), longURL, (expiry time)>

We should ask about the lifespan of the aliases and design a system that purges aliases past their expiration.

### Estimation

LongUrl 100 bytes + shortUrl 6 bytes + STATE 4 bytes = 110 bytes

110 bytes * 3,000,000 = 330 MB per day

330 MB * 365 = 120 GB per year

## Encoding actual longURL Algorithms

### Algorithm 1 - Use MD5/SHA1

E.g. MD5 128bit -> 22 64-Based encoding characters (since each base64 character encodes 6 bits of the hash value)

1) We can take the first 6 (or 7, 8) letters for the key. This could result in key duplication; to resolve that, we can choose some other characters out of the encoding string or swap some characters.

or SHA-1, SHA-2, SHA-256.

62^7 = 3.5 trillion

Pros: It does not need a unique ID generator.

Cons: The collision is possible and needs to be resolved.

### Algorithm 2 - Distributed Seq Unique ID Generator & Base 62 conversion

(Base62: a-z, A-Z, 0-9, 62 chars, 62^7), sharding: each node maintains a section of ids.

This solution utilizes a cluster of id generators that reserve chunks of the id space from a central coordinator (e.g. ZooKeeper) and independently allocate IDs from their chunk, refreshing as necessary.

Pros: Collision can be avoided.

Cons: This needs an additional central coordinator. Also it has security problem because it is easy to figure out what is the next available shortURL (guessable/predictable).

### Algorithm 3 - Others

1) UUID. 32 16-bit characters. 16 Bytes.

2) Multiple MySQL servers. Randomly pick a server.

3) Twitter / Snowflake ID - 64 bits. 1 + 41 timestamp + 10 machine numbers + 12 sequence. Then do the conversion based on 62 or 64. E.g. gk.link/a/3hcCxy

## Flows & Steps

### URL Shortening Steps

1 An user gives a long url input.

(1.5) The web server checks if the same long url is converted before and check if the malicious user.

2 A new unique ID is generated by the unique ID generator.

3 The server converts that ID to short url with base 62 or 64 conversion.

4 The server saves the record to the database and returns the result to the user.

### URL Redirecting Steps

1 An user clicks a short url.

2 The web server checks the validation (like **bloom filter**) first, then checks the cache and returns the long url if it exists.

3 If not, fetch it from the DB.

4 Finally, if it’s present in the DB, issue an “HTTP 302 Redirect” status back to the browser, passing the stored URL in the “Location” field of the request. If that key is not present in our system, issue an “HTTP 404 Not Found” status or redirect the user back to the homepage.

How is the click stats stored? - We can use some form of aggregation tier that accepts click stream data, aggregates it and writes back a persistent data store periodically, rather than choosing the write-back method to a data store on every click.

## Data Partition

Purpose: Scale out DB

Split the DB based on hash function and consistency hashing mechanism.

Consistency Hash: Consistent Hashing stores the data managed by a distributed system in a ring. Each node in the ring is assigned with a range of data.

## Cache

Cache Size : 20K requests/s *3600* 24 = 1.728 billion.

1.728 billion *0.5KB* 20% = 172.8 GB ~ 170 GB.

It can be a single machine based on calculation. LRU strategy.

## Rate Limiter

Ban the malicious user temporarily if it makes requests too many times in a short period of time.

Also we should do rate limit on the number of short url requets for a single user every day. If a user keep requesting the same long url, we can keep a cache and always return the same short url in a certain period of time.

## Expiry - Lazy Clean up

## ID Generator

Each region has a machine as the ID generator. A central data server maintains a table for the range of IDs in each regional machine. E.g.

Machine A (region A) can assign 0-999.

Machine E (region E) can assign 1000-1999.

Machine D (region D) can assign 2000-2999.

...

When a machine has used up its current range (1000 IDs), it is going to apply for a new range to the central data center server. The central server will fetch & return the next range of numbers to it. (It can keep an atomic number or build a DB for maintain the current range mapping).

## Infra Graph

![image](https://www.raychase.net/wp-content/uploads/2020/12/Short-URL.png)

(Source : <https://www.raychase.net/6460>)

## Reference

[1] <https://zybuluo.com/ysongzybl/note/95360>

[2] <https://www.educative.io/courses/grokking-the-system-design-interview/>

[3] [四火的唠叨]<https://www.raychase.net/6460>

[4] System Design Interview. Alex Xu. Chapter 8. Design a url shortener.

[5] <https://www.1point3acres.com/bbs/thread-829896-1-1.html>

[6] <https://tianpan.co/notes/84-designing-a-url-shortener>
